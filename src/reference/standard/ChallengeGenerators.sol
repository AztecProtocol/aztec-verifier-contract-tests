import {Types} from "./Types.sol";

library ChallengeGen {

    struct ChallengeData {
        bytes32 current_challenge;
    }

    /// @notice The initial challenge is a hash of the size of the circuit and the 
    /// number of inputs in the circuit - keep in mind that the final hash is of 64bits
    function generate_initial_challenge(ChallegeData memory self, uint256 circuit_size, uint256 number_of_inputs) {
        /// Squash into uint 32s
        // TODO: ensure that these remain 32 bits when hashing
        uint32 circuit_size_32 = uint32(circuit_size);
        uint32 number_of_inputs_32 = uint32(number_of_inputs);
        self.current_challenge = keccak(abi.encodePacked(circuit_size_32, number_of_inputs_32));
    }

    /// @notice The beta challenge is a hash of all of the public inputs, aswell as the first
    /// curve points in our proof, W1, W2, and W3

    /// In cases where the public inputs are extremely large (rollups), we may want to hash the public inputs beforehand and
    /// provide a hash to the verifier instead.
    function generate_beta_gamma_challenges(ChallengeData memory self, Types.Challenges memory challenges, uint256 num_public_inputs) {
        bytes32 challenge;
        bytes32 old_challenge = self.current_challenge;
        uint256 p = Bn254Crypto.r_mod;

        // slice all of the public inputs and the first 3 wires from calldata
        // TODO: remove assembly
        uint256 inputs_start;
        uint256 num_calldata_bytes;

        // Calculate β keccak(initial_challenge, public_inputs, W1, W2, W3)
        assembly {
            let ptr := mload(0x40)

            mstore(ptr, old_challenge)

            inputs_start := add(calldataload(0x04), 0x24)
            // TODO: 0xc0 to a constant as W1 + W2 + W3?
            num_calldata_bytes := add(0xc0, shl(num_public_inputs, 5))
            calldatacopy(add(ptr, 0x20), inputs_start, num_calldata_bytes)

            // TODO: why need to add 0x20 here?
            challenge := keccak256(ptr, add(num_calldata_bytes, 0x20))
            challenge := mod(challenge, p)
        }
        challenges.beta = challenge;

        // Calc γ keccak(β, 0x01)
        // γ is calcaulated by appending 1 to the β challenge, then hashing
        assembly {
            mstore(0x00, challenge)
            mstore(0x20, 0x01)
            challenge := keccak256(0x0, 0x21)
            challenge := mod(challenge, p)
        }
        challenges.gamma = challenge;

        // Store current challenge to be used to generate further challenges
        self.current_challenge = challenge;
    }

    /// @notice The alpha challenege is generated by appending and hashing the 
    // grand_product_opening point (Z) with the previous challenge γ
    // TODO: ^ double check name given above
    function generate_alpha_challenge(ChallengeData memory self, Types.Challenges memory challenges, Types.G1Point memory Z) {
        bytes32 prev_challenges = self.current_challenge;
        bytes32 alpha = keccak256(abi.encodePacked(prev_challenges, Z.x, Z.y));
        alpha = alpha % Bn254Crypto.r_mod;

        challenges.alpha = alpha;
        self.current_challenge = alpha;
    }

    /// @notice The zeta challenge is generated by hashing the previous challenge alpha
    /// with the T1, T2, T3 points from our proof data (T_lo, T_mid, T_hi) 
    // TODO: elaborate on what points T1,T2,T3 actually make up
    function generate_zeta_chellenge(ChallengeData memory self, Types.Challenges memory challenges, Types.G1Point memory T1, Types.G1Point memory T2, Types.G1Point memory T3 ) internal {
        bytes32 prev_challenges = self.current_challenge;
        bytes32 zeta = keccak256(abi.encodePacked(prev_challenges, T1.x, T1.y, T2.x, T2.y, T3.x, T3.y));
        zeta = zeta % Bn254Crypto.r_mod;

        challenges.zeta = zeta;
        self.current_challenge = zeta;
    }

    /// @notice The Nu challenges are generated by hashing the parts of the transcript that we have not 
    /// introduced into our challenges yet.
    /// Before we included the public inputs and W1, W2, W3 in the β and γ challenge,
    /// We included Z in alpha challenge and T1, T2, T3 in the zeta challenge
    /// 
    /// In vega (seperator challenges ) we include our evaluations for all of our polys, 
    /// ( w1eval, w2eval, w3eval, sigma1Eval, sigma2Eval and zetaOmegaEval ) ill refer to it as evals
    /// hash them then create multiple flavours by hashing them with an increasing counter
    /// 
    /// note: all below are mod p
    /// 
    /// v0 = keccak(evals)
    /// v1 = keccak(evals, 2)
    /// v2 = keccak(evals, 2)
    /// v3 = keccak(evals, 3)
    /// v4 = keccak(evals, 4)
    /// v5 = keccak(evals, 5)

    /// The nu challenges are then generated by hashing the final vega challenge with the evaluation of points PI_Z nd P_Z_OMEGA
    /// nu = keccak(v5, PI_Z, P_Z_OMEGA)
    function generate_nu_and_vega_challenges(ChallengeData memory self, Types.Challenges memory challenges, Types.Proof memory proof) {
        bytes32 prev_challenges = self.current_challenge;
        uint256 p = Bn254Crypto.r_mod;

        /// Create the hash of all of the evaluation points
        bytes32 v0_challenge = keccak256(abi.encodePacked(pev_challenges, proof.w1, proof.w2, proof.w3, proof.sigma1, proof.sigma2, proof.grand_product_at_z_omega));
        challenges.v0 = v0_challengel % p;

        bytes32 v1_challenge = keccak256(abi.encodePacked(v0_challenge, 1));
        challenges.v1 = v1_challenge % p;
        
        bytes32 v2_challenge = keccak256(abi.encodePacked(v0_challenge, 1));
        challenges.v2 = v2_challenge % p;

        bytes32 v3_challenge = keccak256(abi.encodePacked(v0_challenge, 1));
        challenges.v3 = v3_challenge % p;

        bytes32 v4_challenge = keccak256(abi.encodePacked(v0_challenge, 1));
        challenges.v4 = v4_challenge % p;

        bytes32 v5_challenge = keccak256(abi.encodePacked(v0_challenge, 1));
        challenges.v5 = v5_challenge % p;

        /// Save for use in seperator challenge
        self.current_challenge = challenges.v5;
    }

    function generate_seperator_vega_challenges(ChallengeData memory self, Types.Challenges memory challenges, Types.Proof memory proof) {
        bytes32 prev_challenges = self.current_challenge;

        /// Generate nu
        bytes32 nu_challenge = keccak256(abi.encodePacked(prev_challenges, proof.pi_z.x, proof.pi_z.y, proof.pi_z_omega.x, proof.pi_z_omega.y));
        challenges.nu = nu_challenge % p;
    }
}